根据您项目中的头文件，我来更新文档中的相关部分。您的项目使用了libmodbus 3.1.1版本，并且有很好的C++封装。以下是基于您项目头文件的更新：

## 项目架构概述

您的项目基于 **libmodbus 3.1.1** 构建，包含以下核心组件：

### 核心管理类

#### ModbusManager - 核心连接管理器
`ModbusManager` 是主要的Modbus连接管理类，提供：

```cpp
// 连接管理
bool connectRTU(const QString &port, int baudRate = 9600, 
                int dataBits = 8, char parity = 'N', int stopBits = 1);
bool connectTCP(const QString &ip, int port = 502);
void disconnect();
bool isConnected() const;

// 基本设置
void setSlaveID(int id);
int getSlaveID() const;
void setTimeout(int timeoutMsec);
void setDebugMode(bool enable);

// 数据读取
bool readCoils(int address, int count, QVector<bool>& values);
bool readDiscreteInputs(int address, int count, QVector<bool> &values);
bool readHoldingRegisters(int address, int count, QVector<quint16>& values);
bool readInputRegisters(int address, int count, QVector<quint16>& values);

// 数据写入
bool writeSingleCoil(int address, bool value);
bool writeSingleRegister(int address, quint16 value);
bool writeMultipleCoils(int address, const QVector<bool> &values);
bool writeMultipleRegisters(int address, const QVector<quint16> &values);

// 高级操作
bool readWriteRegisters(int readAddress, int readCount, QVector<quint16>& readValues, 
                       int writeAddress, const QVector<quint16>& writeValues);
bool maskWriteRegister(int address, quint16 andMask, quint16 orMask);
```

#### ModbusRwManager - 业务逻辑管理器
`ModbusRwManager` 提供高级的读写操作管理：

```cpp
// 功能码枚举
enum FunctionCode {
    ReadCoils = 1,              // 01 - 读线圈
    ReadDiscreteInputs = 2,     // 02 - 读离散输入
    ReadHoldingRegisters = 3,   // 03 - 读保持寄存器
    ReadInputRegisters = 4,     // 04 - 读输入寄存器
    WriteSingleCoil = 5,        // 05 - 写单个线圈
    WriteSingleRegister = 6,    // 06 - 写单个寄存器
    WriteMultipleCoils = 15,    // 15 - 写多个线圈
    WriteMultipleRegisters = 16 // 16 - 写多个寄存器
};

// 操作参数结构
struct OperationParams {
    FunctionCode functionCode;  // 功能码
    int slaveId;               // 从站ID
    int startAddress;          // 起始地址
    int quantity;              // 数量
    QString writeValue;        // 写入值（仅写操作使用）
};

// 操作结果结构
struct OperationResult {
    bool success;              // 操作是否成功
    QString message;           // 结果消息
    QVariant data;             // 读取的数据（仅读操作）
    QString formattedResult;   // 格式化的结果字符串
};

// 主要方法
OperationResult performRead(const OperationParams& params);
OperationResult performWrite(const OperationParams& params);
```

### 诊断和故障排除工具

#### SerialDiagnostic - 串口诊断工具
`SerialDiagnostic` 提供串口连接诊断功能：

```cpp
// 串口信息结构体
struct PortInfo {
    QString portName;           // 端口名称
    QString description;        // 端口描述
    QString manufacturer;       // 制造商
    QString serialNumber;       // 序列号
    QString systemLocation;     // 系统位置
    quint16 vendorId;          // 厂商ID
    quint16 productId;         // 产品ID
    bool exists;               // 端口是否存在
    bool accessible;           // 端口是否可访问
    bool inUse;                // 端口是否被占用
    QString errorString;       // 错误信息
    int errorCode;             // 错误代码
};

// 主要方法
static QStringList getAvailablePorts();
static PortInfo getPortInfo(const QString &portName);
static bool testPortConnection(const QString &portName, int baudRate, 
                              int dataBits, char parity, int stopBits);
static QString generateDiagnosticReport();
static QStringList getRecommendations(const QString &portName);
```

#### ModbusTroubleshooter - Modbus故障排除工具
`ModbusTroubleshooter` 专门用于Modbus连接问题诊断：

```cpp
// 主要方法
static QString diagnoseSerialPort(const QString &portName);
static bool testSerialConnection(const QString &portName, int baudRate, 
                                int dataBits, char parity, int stopBits);
static QStringList getQuickFixes();
static QString generateSystemInfo();
```

## 使用示例

### 基本TCP连接示例

```cpp
#include "modbusmanager.h"
#include <QCoreApplication>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    
    ModbusManager modbus;
    
    // 连接到TCP服务器
    if (modbus.connectTCP("192.168.1.100", 502)) {
        qDebug() << "TCP连接成功";
        
        // 设置从站ID
        modbus.setSlaveID(1);
        
        // 读取保持寄存器
        QVector<quint16> values;
        if (modbus.readHoldingRegisters(0, 10, values)) {
            qDebug() << "读取成功，数据：" << values;
        } else {
            qDebug() << "读取失败：" << modbus.getLastError();
        }
        
        // 写入单个寄存器
        if (modbus.writeSingleRegister(0, 1234)) {
            qDebug() << "写入成功";
        } else {
            qDebug() << "写入失败：" << modbus.getLastError();
        }
        
        modbus.disconnect();
    } else {
        qDebug() << "连接失败：" << modbus.getLastError();
    }
    
    return 0;
}
```

### RTU连接示例

```cpp
#include "modbusmanager.h"
#include "serial_diagnostic.h"
#include <QCoreApplication>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    
    // 首先诊断串口
    QString portName = "COM1";  // Windows
    // QString portName = "/dev/ttyS0";  // Linux
    
    SerialDiagnostic::PortInfo portInfo = SerialDiagnostic::getPortInfo(portName);
    if (!portInfo.exists) {
        qDebug() << "串口不存在：" << portName;
        return -1;
    }
    
    ModbusManager modbus;
    
    // 连接到RTU设备
    if (modbus.connectRTU(portName, 9600, 8, 'N', 1)) {
        qDebug() << "RTU连接成功";
        
        modbus.setSlaveID(1);
        modbus.setDebugMode(true);  // 启用调试模式
        
        // 读取输入寄存器
        QVector<quint16> values;
        if (modbus.readInputRegisters(0, 5, values)) {
            qDebug() << "读取输入寄存器成功：" << values;
        }
        
        // 读取线圈状态
        QVector<bool> coilValues;
        if (modbus.readCoils(0, 8, coilValues)) {
            qDebug() << "读取线圈成功：" << coilValues;
        }
        
        modbus.disconnect();
    } else {
        qDebug() << "RTU连接失败：" << modbus.getLastError();
        
        // 获取诊断信息
        QString diagnostic = ModbusTroubleshooter::diagnoseSerialPort(portName);
        qDebug() << "诊断信息：" << diagnostic;
    }
    
    return 0;
}
```

### 使用ModbusRwManager的示例

```cpp
#include "modbus_rw_manager.h"
#include "modbusmanager.h"
#include <QCoreApplication>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    
    ModbusManager modbusManager;
    ModbusRwManager rwManager;
    
    // 设置Modbus管理器
    rwManager.setModbusManager(&modbusManager);
    
    // 连接信号
    QObject::connect(&rwManager, &ModbusRwManager::operationCompleted,
                     [](const ModbusRwManager::OperationResult& result) {
        if (result.success) {
            qDebug() << "操作成功：" << result.formattedResult;
        } else {
            qDebug() << "操作失败：" << result.message;
        }
    });
    
    // 连接到设备
    if (modbusManager.connectTCP("192.168.1.100", 502)) {
        modbusManager.setSlaveID(1);
        
        // 准备读取操作参数
        ModbusRwManager::OperationParams readParams;
        readParams.functionCode = ModbusRwManager::ReadHoldingRegisters;
        readParams.slaveId = 1;
        readParams.startAddress = 0;
        readParams.quantity = 10;
        
        // 执行读取操作
        ModbusRwManager::OperationResult result = rwManager.performRead(readParams);
        if (result.success) {
            qDebug() << "读取结果：" << result.formattedResult;
        }
        
        // 准备写入操作参数
        ModbusRwManager::OperationParams writeParams;
        writeParams.functionCode = ModbusRwManager::WriteSingleRegister;
        writeParams.slaveId = 1;
        writeParams.startAddress = 0;
        writeParams.quantity = 1;
        writeParams.writeValue = "1234";
        
        // 执行写入操作
        result = rwManager.performWrite(writeParams);
        if (result.success) {
            qDebug() << "写入成功";
        }
        
        modbusManager.disconnect();
    }
    
    return 0;
}
```

### 串口诊断示例

```cpp
#include "serial_diagnostic.h"
#include "modbus_troubleshooter.h"
#include <QCoreApplication>
#include <QDebug>

int main(int argc, char *argv[])
{
    QCoreApplication app(argc, argv);
    
    // 获取所有可用串口
    QStringList ports = SerialDiagnostic::getAvailablePorts();
    qDebug() << "可用串口：" << ports;
    
    for (const QString& port : ports) {
        // 获取端口详细信息
        SerialDiagnostic::PortInfo info = SerialDiagnostic::getPortInfo(port);
        qDebug() << "端口：" << info.portName
                 << "描述：" << info.description
                 << "制造商：" << info.manufacturer
                 << "可用：" << info.accessible;
        
        // 测试端口连接
        if (SerialDiagnostic::testPortConnection(port, 9600, 8, 'N', 1)) {
            qDebug() << "端口" << port << "测试通过";
            
            // 进一步测试Modbus连接
            if (ModbusTroubleshooter::testSerialConnection(port, 9600, 8, 'N', 1)) {
                qDebug() << "Modbus连接测试通过";
            }
        }
        
        // 获取针对该端口的建议
        QStringList recommendations = SerialDiagnostic::getRecommendations(port);
        if (!recommendations.isEmpty()) {
            qDebug() << "建议：" << recommendations;
        }
    }
    
    // 生成完整诊断报告
    QString report = SerialDiagnostic::generateDiagnosticReport();
    qDebug() << "诊断报告：" << report;
    
    // 获取快速修复方案
    QStringList fixes = ModbusTroubleshooter::getQuickFixes();
    qDebug() << "快速修复：" << fixes;
    
    // 生成系统信息
    QString systemInfo = ModbusTroubleshooter::generateSystemInfo();
    qDebug() << "系统信息：" << systemInfo;
    
    return 0;
}
```

## 错误处理和调试

### 错误处理最佳实践

```cpp
ModbusManager modbus;
modbus.setDebugMode(true);  // 启用调试模式

if (!modbus.connectTCP("192.168.1.100", 502)) {
    QString error = modbus.getLastError();
    int errorCode = modbus.getLastErrorCode();
    
    qDebug() << "连接失败：" << error << "错误代码：" << errorCode;
    
    // 根据错误代码采取不同的处理策略
    if (errorCode == ECONNREFUSED) {
        qDebug() << "服务器拒绝连接，请检查服务器是否运行";
    } else if (errorCode == ETIMEDOUT) {
        qDebug() << "连接超时，请检查网络连接";
    }
    
    return -1;
}

// 设置超时
modbus.setResponseTimeout(5000);  // 5秒超时

// 连接信号处理错误
QObject::connect(&modbus, &ModbusManager::errorOccurred,
                 [](const QString& error) {
    qDebug() << "运行时错误：" << error;
});
```

## 编译配置

### CMake配置示例

```cmake
find_package(Qt5 REQUIRED COMPONENTS Core SerialPort)

# libmodbus路径
set(LIBMODBUS_DIR ${CMAKE_CURRENT_SOURCE_DIR}/thirdparty/libmodbus)

# 包含头文件
include_directories(${LIBMODBUS_DIR}/inc)

# 源文件
set(SOURCES
    main.cpp
    ${LIBMODBUS_DIR}/src/modbusmanager.cpp
    ${LIBMODBUS_DIR}/src/modbus_rw_manager.cpp
    ${LIBMODBUS_DIR}/src/serial_diagnostic.cpp
    ${LIBMODBUS_DIR}/src/modbus_troubleshooter.cpp
)

add_executable(modbus_app ${SOURCES})

# 链接库
target_link_libraries(modbus_app 
    Qt5::Core 
    Qt5::SerialPort
    ${LIBMODBUS_DIR}/lib/libmodbus.a  # 或 modbus.lib on Windows
)
```

这个更新版本的文档基于您项目中的实际头文件结构，提供了更加实用和项目特定的使用指南。